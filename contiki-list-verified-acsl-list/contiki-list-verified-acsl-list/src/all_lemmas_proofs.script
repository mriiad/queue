(*
  Copyright (c) 2018, Inria, CEA, Northern Arizona University.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.
  3. Neither the name of the Institute nor the names of its contributors
     may be used to endorse or promote products derived from this software
     without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGE.

  This file is part of the verification of the Contiki operating system.

  Authors: - Allan Blanchard <mail@allan-blanchard.fr>
           - Nikolai Kosmatov <nikolai.kosmatov@cea.fr>
           - Frédéric Loulergue <frederic.loulergue@nau.edu>
*)

(* Generated by Frama-C WP *)

Goal typed_lemma_all_separated_in_list_added_element.
Hint all_separated_in_list_added_element,property.
Proof.
  intros l1 l2 element L ; unfold L ; clear L.
  rewrite rw_nil_concat_right.
  intros H Plus.
  intros x1 x2 Neq L2 L1 U2 U1.
  assert (H1: x1 < length(l1) \/ length(l1) = x1 \/ length(l1) < x1 < 1 + length(l1)+length(l2)) by
    (rewrite Vlist.length_concat in U1 ; rewrite Vlist.length_cons in U1 ; omega).
  assert (H2: x2 < length(l1) \/ length(l1) = x2 \/ length(l1) < x2 < 1 + length(l1)+length(l2)) by
    (rewrite Vlist.length_concat in U2 ; rewrite Vlist.length_cons in U2 ; omega).
  assert (HL1: 0 <= length l1) by apply Vlist.length_pos.
  assert (HL2: 0 <= length l2) by apply Vlist.length_pos.
  repeat match goal with [ H: _ \/ _ |- _ ] => destruct H end ;
  repeat match goal with
  | [ H: ?x < length l1 |- context [ nth (concat l1 (cons element l2)) ?x ] ] =>
    replace (nth (concat l1 (cons element l2)) x)
       with (nth l1 x)
         by (symmetry ; apply Vlist.nth_concat ; omega) ;
    replace (nth l1 x) with (nth (concat l1 l2) x)
         by (apply Vlist.nth_concat ; omega)
  | [ H: length l1 = ?x |- context [ nth (concat l1 (cons element l2)) ?x ] ] =>
    replace (nth (concat l1 (cons element l2)) x) 
       with (nth (cons element l2) (length l1 - length l1)) 
         by (subst ; symmetry ; apply Vlist.nth_concat ; omega) ;
    replace (length l1 - length l1) with 0 by omega ; simpl
  | [ H: length l1 < ?x < 1 + length l1 + length l2 |- context [ nth (concat l1 (cons element l2)) ?x ] ] =>
    replace (nth (concat l1 (cons element l2)) x) 
      with (nth (cons element l2) (x - length l1))
        by (symmetry ; apply Vlist.nth_concat ; try omega) ;
    replace (nth (cons element l2) (x - length l1))
      with (nth l2 (x - length l1 - 1))
        by (symmetry ; apply Vlist.nth_cons ; omega) ;
    replace (nth l2 (x - length l1 - 1)) 
       with (nth (concat l1 l2) (x - 1)) by (
      replace (x - length l1 - 1) with (x - 1 - length l1) by omega ;
      apply Vlist.nth_concat ; omega)
  end ;
  try (apply H) ;
  try (apply Plus) ;
  try (apply separated_sym ; apply Plus) ;
  try rewrite Vlist.length_concat in * ;
  try rewrite Vlist.length_cons in U2, U1 ; omega.
Qed.

Goal typed_lemma_all_separated_in_list_removed_element.
Hint all_separated_in_list_removed_element,property.
Proof.
  intros l1 l2 element.
  rewrite rw_nil_concat_right.
  intros H.
  intros x1 x2 Neq L2 L1 U2 U1.
  assert (H1: x1 < length(l1) \/ length(l1) <= x1 < length(l1)+length(l2)) by
    (rewrite Vlist.length_concat in U1 ; omega).
  assert (H2: x2 < length(l1) \/ length(l1) <= x2 < length(l1)+length(l2)) by
    (rewrite Vlist.length_concat in U2 ; omega).
  clear U1 U2.
  destruct H1 ; destruct H2 ;
  repeat match goal with
  | [ H: ?x < length l1 |- context [ nth (concat l1 l2) ?x ] ] =>
    replace (nth (concat l1 l2) x)
       with (nth l1 x)
         by (symmetry ; apply Vlist.nth_concat ; omega) ;
    replace (nth l1 x) with (nth (concat l1 (cons element l2)) x)
         by (apply Vlist.nth_concat ; omega)
  | [ H: length l1 <= ?x < length l1 + length l2 |- context [ nth (concat l1 l2) ?x ] ] =>
    replace (nth (concat l1 l2) x)
       with (nth l2 (x - length l1))
         by (symmetry ; apply Vlist.nth_concat ; omega) ;
    replace (nth l2 (x - length l1)) with (nth (concat l1 (cons element l2)) (x + 1)) by (
      replace (nth l2 (x - length l1)) with (nth (cons element l2) (x - length l1 + 1)) by (
        replace (x - length l1) with (x - length l1 + 1 - 1) by omega ;
        replace (x - length l1 + 1 - 1 + 1) with (x - length l1 + 1) by omega ;
        apply Vlist.nth_cons ; omega) ;
      replace (x - length l1 + 1) with (x + 1 - length l1) by omega ;
      apply Vlist.nth_concat ; omega)
  end ; try apply H ; try omega ;
  rewrite Vlist.length_concat ; 
  rewrite Vlist.length_cons ;
  assert(0 <= length l2) by apply length_pos ; omega.
Qed.

Goal typed_lemma_dptr_separated_concat.
Hint dptr_separated_concat,property.
Proof.
  intros l1 ; induction l1 as [| h1 l1] ; intros l2 e.
  + replace Datatypes.nil with nil by reflexivity.
    rewrite rw_nil_concat_right.
    rewrite rw_nil_concat_left.
    repeat (split ; intros) ; try apply H ; apply Q_dptr_separated_from_nil.
  + replace ((h1 :: l1)%list) with (cons h1 l1) by reflexivity.
    rewrite rw_cons_concat.
    replace (cons h1 (concat l1 (concat l2 nil))) 
       with (cons h1 (concat (concat l1 (concat l2 nil)) nil))
         by (repeat(rewrite rw_nil_concat_right) ; auto).
    split ; intros H.
    - rewrite <- Q_dptr_separated_from_cons.
      replace l1 with (concat l1 nil) in H by (apply rw_nil_concat_right).
      rewrite <- Q_dptr_separated_from_cons in H.
      split ; try (rewrite <- IHl1 ; split) ; apply H.
    - rewrite <- Q_dptr_separated_from_cons in H.
      rewrite <- IHl1 in H.
      replace l1 with (concat l1 nil) by (apply rw_nil_concat_right).
      split ; try (rewrite <- Q_dptr_separated_from_cons ; split) ; apply H.
Qed.

Goal typed_lemma_dptr_separated_from_cons.
Hint dptr_separated_from_cons,property.
Proof.
  intros l ; induction l ; intros e hd ; simpl.
  + unfold cons.
    repeat(split ; intros).
    - intros i ; intros.
      assert(i = 0) by (unfold length in * ; simpl in *  ; omega) ; subst.
      simpl ; apply H.
    - apply Q_dptr_separated_from_nil.
    - unfold P_dptr_separated_from_list in H.
      assert (hd = nth (hd :: nil)%list 0) by (simpl ; auto).
      rewrite H0 ; apply H ; unfold length ; simpl ; auto ; omega.
  + unfold cons, concat.
    rewrite List.app_nil_r.
    replace ((a :: l)%list) with (cons a l) by reflexivity.
    replace l with (concat l nil) by (rewrite rw_nil_concat_right ; auto).
    replace ( (hd :: cons a (concat l nil))%list)
       with (cons hd (cons a (concat l nil)))
         by reflexivity.
    repeat(split ; intros).
    - intros i LL Li Ui.
      assert (i = 0 \/ i <> 0) by omega.
      inversion_clear H0 as [ Eq | Neq ] ; intros.
      * subst ; simpl ; apply H.
      * replace (nth (cons hd (cons a (concat l nil))) i)
           with (nth (cons a (concat l nil)) (i - 1))
             by (symmetry ; apply Vlist.nth_cons ; omega).
        apply H ; rewrite Vlist.length_cons in Ui ; omega.
    - intros i LL Li Ui ; intros.
      replace i with (i + 1 - 1) by omega.
      replace (nth (cons a (concat l nil)) (i + 1 - 1))
         with (nth (cons hd (cons a (concat l nil))) (i + 1))
           by (apply Vlist.nth_cons ; omega).
      apply H ; try rewrite Vlist.length_cons ; omega.
    - assert (hd = nth (cons hd (cons a (concat l nil)))%list 0) by (simpl ; auto).
      rewrite H0 ; apply H ; try omega.
      rewrite Vlist.length_cons.
      assert (0 <= length (cons a (concat l nil))) by apply Vlist.length_pos.
      omega.
Qed.

Goal typed_lemma_in_list_in_sublist.
Hint in_list_in_sublist,property.
Proof.
  intros rl ll l.
  rewrite rw_nil_concat_right.
  assert(Lenl: 0 <= length ll) by apply Vlist.length_pos.
  assert(Lenr: 0 <= length rl) by apply Vlist.length_pos.
  split ; intros H.
  + inversion_clear H as [ H' | H' ] ; inversion H' as [ v P ] ;
      [ exists (v + length rl) | exists v ] ; 
      split ; try( rewrite Vlist.length_concat ; omega ) ;
      inversion_clear P as [ Nth Bound ].
    - replace v with (v + length rl - length rl) in Nth by omega.
      rewrite <- Nth.
      apply Vlist.nth_concat ; omega.
    - rewrite <- Nth.
      apply Vlist.nth_concat ; omega.
  + inversion H as [ v P ] ; inversion_clear P as[ Nth Len ].
    rewrite Vlist.length_concat in Len.
    assert (Cases: 0 <= v < length rl \/ length rl <= v < length ll + length rl) by omega.
    inversion_clear Cases as [ R | L ].
    - right ; exists v ; split ; auto.
      rewrite <- Nth ; symmetry ; apply Vlist.nth_concat ; omega.
    - left ; exists (v - length rl) ; split ; try omega.
      rewrite <- Nth ; symmetry ; apply Vlist.nth_concat ; omega.
Qed.

Goal typed_lemma_inversion_linked_ll.
Hint inversion_linked_ll,property.
Proof.
  intros Mi Ma ll bl el NoDup.
  inversion NoDup ; subst ; auto.
  right ; exists l ; repeat(split ; auto).
  intros HF ; subst ; inversion H1 ; omega.
Qed.

Goal typed_lemma_n_plus_1th_next.
Hint n_plus_1th_next,property.
Proof.
  intros Mi Ma ll bl el NoDup.
  induction NoDup ; intros i Li Hi.
  + rewrite length_nil in Hi ; omega.
  + subst.
    inversion NoDup ; subst.
    - rewrite Vlist.length_cons in Hi.
      rewrite rw_nil_concat_right in Hi.
      subst.
      rewrite length_nil in Hi ; omega.
    - assert(Cases: i = 0 \/ 0 < i) by omega.
      inversion_clear Cases as [ Eq | Neq ] ; subst.
      * repeat(rewrite rw_nil_concat_right).
        unfold nth ; simpl ; auto.
      * repeat(rewrite rw_nil_concat_right).
        repeat(rewrite rw_nil_concat_right in IHNoDup).
        replace (nth (cons a_1 (cons (t_1 .[ shiftfield_F1_list_next a_1]) l0)) i)
           with (nth (cons (t_1 .[ shiftfield_F1_list_next a_1]) l0) (i-1)) 
             by (symmetry ; apply Vlist.nth_cons ; omega).
        replace (nth (cons a_1 (cons (t_1 .[ shiftfield_F1_list_next a_1]) l0)) (1 + i))
           with (nth (cons (t_1 .[ shiftfield_F1_list_next a_1]) l0) (1 + (i - 1))).
        ++ apply IHNoDup ; try omega.
           repeat(rewrite rw_nil_concat_right in Hi).
           repeat(rewrite Vlist.length_cons in Hi).
           repeat(rewrite Vlist.length_cons).
           omega.
        ++ replace (1 + (i - 1)) with ((1 + i) - 1) by omega.
           symmetry ; apply Vlist.nth_cons ; omega.
Qed.

Goal typed_lemma_linked_ll_all_separated.
Hint linked_ll_all_separated,property.
Proof.
  Ltac cnil_match := match goal with
  | [ H : context [ concat _ nil ] |- _ ] => rewrite rw_nil_concat_right in H
  | [ |- context [ concat _ nil ] ] => rewrite rw_nil_concat_right
  end.
  Ltac cnil := repeat(cnil_match).

  intros Mi Ma ll bl el NoDup.
  induction NoDup ; intros n1 n2.
  + unfold length ; simpl ; intros ; omega.
  + intros neq Ln2 Ln1 Un2 Un1.
    assert(Nth: forall n, n + 1 <> 0 -> nth l n = nth (cons a_1 l) (n + 1)). {
      intros n ; replace n with ((n + 1) - 1) by omega.
      replace (n + 1 - 1 + 1) with (n + 1) by omega.
      symmetry ; apply Vlist.nth_cons ; omega.
    }
    destruct n1 using Z_induction with (m := 0); 
    destruct n2 using Z_induction with (m := 0);
    try omega ; cnil.
    - assert (n1 = 0) by omega ; subst.
      replace (nth (cons a_1 l) 0) with a_1 by (unfold nth ; auto).
      replace (nth (cons a_1 l) (n2 + 1)) with (nth l n2) by (apply Nth ; omega).
      apply separated_sym ; apply H ; rewrite Vlist.length_cons in Un2 ; omega.
    - assert (n2 = 0) by omega ; subst.
      replace (nth (cons a_1 l) 0) with a_1 by (unfold nth ; auto).
      replace (nth (cons a_1 l) (n1 + 1)) with (nth l n1) by (apply Nth ; omega).
      apply H ; rewrite Vlist.length_cons in Un1 ; omega.
    - replace (nth (cons a_1 l) (n1 + 1)) with (nth l n1) by (apply Nth ; omega).
      replace (nth (cons a_1 l) (n2 + 1)) with (nth l n2) by (apply Nth ; omega).
      apply IHNoDup ; (rewrite Vlist.length_cons in Un2, Un1) ; omega.
Qed.

Goal typed_lemma_linked_ll_end.
Hint linked_ll_end,property.
Proof.
  intros Mi Ma ll bl el Hnil NoDup.
  generalize dependent Hnil.
  induction NoDup.
  + congruence.
  + destruct l.
    - replace Datatypes.nil with nil in * by reflexivity.
      intros.
      repeat(rewrite rw_nil_concat_right).
      inversion NoDup ; subst.
      rewrite Vlist.length_cons.
      rewrite Vlist.length_nil.
      unfold nth ; simpl ; auto.
    - repeat(rewrite rw_nil_concat_right).
      rewrite Vlist.length_cons.
      replace (1 + length (a0 :: l)%list - 1) with (length (a0 :: l)%list) by omega.
      replace (nth (cons a_1 (a0 :: l)%list) (length (a0 :: l)%list))
         with (nth (a0 :: l)%list (length (a0 :: l)%list - 1)).
      * intros.
        apply IHNoDup ; auto.
        inversion NoDup ; subst.
        intros HF ; inversion HF.
      * symmetry ; apply Vlist.nth_cons.
        replace (a0 :: l)%list with (cons a0 l) by reflexivity.
        rewrite Vlist.length_cons.
        assert(0 <= length l) by (apply Vlist.length_pos) ; omega.
Qed.

Goal typed_lemma_linked_ll_end_not_in.
Hint linked_ll_end_not_in,property.
Proof.
  intros Mi Ma ll bl el NoDup.
  induction NoDup.
  + intros HF ; inversion HF ; inversion H.
    unfold length in * ; simpl in * .
    omega.
  + intros HF ; inversion HF ; subst ; auto.
    repeat (rewrite rw_nil_concat_right in H2).
    assert(Hx: x = 0 \/ 0 < x) by omega ; inversion_clear Hx.
    - subst ; unfold nth in H2 ; simpl in H2 ; inversion H2 ; subst.
      inversion H1 ; omega.
    - apply IHNoDup.
      unfold P_in_list ; exists (x-1) ; split.
      * inversion_clear H2 ; subst.
        symmetry ; apply Vlist.nth_cons ; omega.
      * inversion_clear H2 ; subst.
        rewrite Vlist.length_cons in H5 ; omega.
Qed.

Goal typed_lemma_linked_ll_end_separated.
Hint linked_ll_end_separated,property.
Proof.
  intros Mi Ma ll bl el NoDup.
  induction NoDup.
  + constructor ; rewrite length_nil in H1 ; omega.
  + unfold P_ptr_separated_from_list.
    unfold P_ptr_separated_from_range.
    intros i ; intros LL Li Ui UU.
    assert (HH: i = 0 \/ 0 < i ) by omega.
    inversion_clear HH ; subst.
    - unfold nth, cons ; simpl ; auto.
    - rewrite rw_nil_concat_right.
      replace (nth (cons a_1 l) i) with (nth l (i-1)) 
           by (symmetry ; apply Vlist.nth_cons ; omega).
      apply IHNoDup ; try omega.
      rewrite length_cons in Ui.
      rewrite rw_nil_concat_right in Ui.
      omega.
Qed.

Goal typed_lemma_linked_ll_in_beg_xor_end.
Hint linked_ll_in_beg_xor_end,property.
Proof.
  intros Mi Ma l1 l2 bl el e NoDup.
  rewrite rw_nil_concat_right in NoDup.
  apply Q_linked_ll_all_separated in NoDup.
  split ; intros H1 H2 ;
    inversion_clear H1 as [ n1 H1' ] ; inversion_clear H1' ;
    inversion_clear H2 as [ n2 H2' ] ; inversion_clear H2' .
  + assert (HH: n1 <> n2 + length l1) by omega.
    apply NoDup in HH.
    replace (nth (concat l1 l2) n1) with (nth l1 n1) in HH.
    replace (nth (concat l1 l2) (n2 + length l1)) with (nth l2 n2) in HH.
    subst ; rewrite H1 in HH.
    assert (H: 0 <= n2 + length l1) by omega ; 
      apply HH in H ; try rewrite Vlist.length_concat ; try omega.
    inversion H ; omega. 
    - replace n2 with (length l1 + n2 - length l1) by omega.
      replace (length l1 + n2 - length l1 + length l1) with (length l1 + n2) by omega.
      symmetry ; apply Vlist.nth_concat ; omega.
    - symmetry ; apply Vlist.nth_concat ; omega.
  + assert (HH: n2 <> n1 + length l1) by omega.
    apply NoDup in HH.
    replace (nth (concat l1 l2) n2) with (nth l1 n2) in HH.
    replace (nth (concat l1 l2) (n1 + length l1)) with (nth l2 n1) in HH.
    subst ; rewrite H1 in HH.
    assert (H: 0 <= n1 + length l1) by omega ; 
      apply HH in H ; try rewrite Vlist.length_concat ; try omega.
    inversion H ; omega. 
    - replace n1 with (length l1 + n1 - length l1) by omega.
      replace (length l1 + n1 - length l1 + length l1) with (length l1 + n1) by omega.
      symmetry ; apply Vlist.nth_concat ; omega.
    - symmetry ; apply Vlist.nth_concat ; omega.
Qed.

Goal typed_lemma_linked_ll_in_points_to_same.
Hint linked_ll_in_points_to_same,property.
Proof.
  intros Mi Ma ll bl el a b EqNext InB InA NoDup.
  assert (Contra: a <> b -> Ma .[ shiftfield_F1_list_next a] <> Ma .[ shiftfield_F1_list_next b]). {
    intros HF.
    inversion_clear InB as [ pb HB ] ; inversion_clear HB as [ NthB BoundsB ].
    inversion_clear InA as [ pa HA ] ; inversion_clear HA as [ NthA BoundsA ].
    assert(Cases: { pb = pa } + { pb <> pa }) by repeat decide equality.
    inversion_clear Cases as [ Eq | Neq ].
    + subst ; contradiction.
    + assert (Hpb: 0 <= pb < (length ll - 1) \/ pb = (length ll - 1)) by omega ; clear BoundsB.
      assert (Hpa: 0 <= pa < (length ll - 1) \/ pa = (length ll - 1)) by omega ; clear BoundsA.
      inversion_clear Hpb ; inversion_clear Hpa ; try omega.
      - assert (NthNB: Ma .[ shiftfield_F1_list_next b] = nth ll (1 + pb)). {
          subst ; eapply Q_n_plus_1th_next ; [ apply NoDup | omega | omega ].
        }
        assert (NthNA: Ma .[ shiftfield_F1_list_next a] = nth ll (1 + pa)). {
          subst ; eapply Q_n_plus_1th_next ; [ apply NoDup | omega | omega ].
        }
        apply Q_linked_ll_all_separated in NoDup.
        assert (HH: 1 + pb <> 1 + pa) by omega ; apply NoDup in HH.
        assert (P1: 0 <= 1 + pa) by omega ; apply HH in P1 ; try omega.
        assert (EQ: nth ll (1 + pb) = nth ll (1 + pa)) by congruence.
        rewrite EQ in P1.
        inversion P1 ; omega.
      - assert (NthNB: Ma .[ shiftfield_F1_list_next b] = nth ll (1 + pb)). {
          subst ; eapply Q_n_plus_1th_next ; [ apply NoDup | omega | omega ].
        }
        assert (EndNA: Ma .[ shiftfield_F1_list_next a] = el). {
          subst ; eapply Q_linked_ll_end ; [ | apply NoDup ].
          intros HF2 ; subst ; unfold length in * ; simpl in * ; omega.
        }
        assert (EQ: el = nth ll (1 + pb)) by congruence.
        apply Q_linked_ll_end_not_in in NoDup.
        exfalso.
        apply NoDup ; exists (1 + pb) ; split ; auto ; omega.
      - assert (EndNB: Ma .[ shiftfield_F1_list_next b] = el). {
          subst ; eapply Q_linked_ll_end ; [ | apply NoDup ].
          intros HF2 ; subst ; unfold length in * ; simpl in * ; omega.
        }
        assert (NthNA: Ma .[ shiftfield_F1_list_next a] = nth ll (1 + pa)). {
          subst ; eapply Q_n_plus_1th_next ; [ apply NoDup | omega | omega ].
        }
        assert (EQ: el = nth ll (1 + pa)) by congruence.
        apply Q_linked_ll_end_not_in in NoDup.
        exfalso.
        apply NoDup ; exists (1 + pa) ; split ; auto ; omega.
  }
  assert (Cases: { a = b } + { a <> b }) by repeat decide equality.
  inversion Cases as [ Eq | Neq ]; auto.
  apply Contra in Neq ; contradiction.
Qed.

Goal typed_lemma_linked_ll_in_valid.
Hint linked_ll_in_valid,property.
Proof.
  intros Mi Ma ll bl el NoDup.
  induction NoDup ; intros n Ln Un.
  - rewrite Vlist.length_nil in Un ; omega.
  - assert(Cases: n = 0 \/ 0 < n ) by omega.
    inversion_clear Cases as [ Fst | Next ].
    + subst ; unfold nth ; auto.
    + replace (nth (cons a_1 (concat l nil)) n)
         with (nth (concat l nil) (n-1))
           by (symmetry ; apply Vlist.nth_cons ; omega).
      rewrite rw_nil_concat_right ; apply IHNoDup ; try omega.
      rewrite Vlist.length_cons in Un.
      rewrite rw_nil_concat_right in Un.
      omega.
Qed.

Goal typed_lemma_linked_ll_merge.
Hint linked_ll_merge,property.
Proof.
  intros Mi Ma l1 l2 bl sl el ll.
  unfold ll ; clear ll.
  rewrite rw_nil_concat_right.
  revert l2 bl sl el.
  induction l1 as [ | hd1 l1' ].
  + intros l2 bl sl el Sep_end sep All_sep NoDup2 NoDup1.
    replace Datatypes.nil with nil in * by reflexivity.
    rewrite rw_nil_concat_left.
    inversion NoDup1 ; subst ; auto.
  + destruct l1' as [ | snd1 l1'' ].
    - intros l2 bl sl el Sep_end sep All_sep NoDup2 NoDup1.
      simpl in * .
      replace (hd1 :: l2)%list with (cons hd1 l2) in * by reflexivity.
      inversion NoDup1 ; subst.
      replace l2 with (concat l2 nil) by apply rw_nil_concat_right.
      constructor ; auto.
      * replace hd1 with (nth (cons hd1 l2) 0) by (unfold nth ; auto).
        intros i ; intros.
        replace (nth l2 i) with (nth (cons hd1 l2) (i+1)).
        ++ apply All_sep ; try (rewrite Vlist.length_cons) ; omega.
        ++ replace i with (i + 1 - 1) by omega.
           replace (i + 1 - 1 + 1) with (i + 1) by omega.
           apply Vlist.nth_cons ; omega.
      * replace Datatypes.nil with nil in * by reflexivity.
        rewrite rw_nil_concat_right in H0 ; subst ; inversion H8 ; subst ; auto.
    - replace (snd1 :: l1'')%list with (cons snd1 l1'') in * by reflexivity.
      set(l1' := cons snd1 l1'').
      replace (hd1 :: l1')%list with (cons hd1 l1') in * by reflexivity.
      intros l2 bl sl el Sep_end sep All_sep NoDup2 NoDup1.
      rewrite rw_cons_concat.
      inversion NoDup1 ; subst.
      rewrite rw_nil_concat_right in H0 ; subst.
      rewrite rw_nil_concat_right.
      replace (concat l1' l2) with (concat (concat l1' l2) nil)
           by apply rw_nil_concat_right.
      constructor ; auto.
      * rewrite rw_cons_concat in All_sep.
        replace hd1 with (nth (cons hd1 (concat l1' l2)) 0) by (unfold nth ; auto).
        intros i ; intros.
        replace (nth (concat l1' l2) i) with (nth (cons hd1 (concat l1' l2)) (i+1)).
        ++ apply All_sep ; try (rewrite Vlist.length_cons) ; omega.
        ++ replace i with (i + 1 - 1) by omega.
           replace (i + 1 - 1 + 1) with (i + 1) by omega.
           apply Vlist.nth_cons ; omega.
      * apply IHl1' with (sl := sl) ; auto.
        ++ intros i ; intros.
           replace (nth (cons snd1 l1'') i) with (nth (cons hd1 l1') (i+1)).
           -- apply Sep_end ; try omega.
              rewrite Vlist.length_cons ; unfold l1' ; omega.
           -- replace i with (i + 1 - 1) by omega.
              replace (i + 1 - 1 + 1) with (i + 1) by omega.
              unfold l1' ; apply Vlist.nth_cons ; omega.
        ++ unfold l1' in * ; inversion H8 ; subst.
           replace (Ma .[ shiftfield_F1_list_next hd1])
              with (nth (cons hd1 (cons (Ma .[ shiftfield_F1_list_next hd1]) (concat l nil))) 1)
                by (unfold nth ; auto).
           apply Sep_end ; try omega.
           repeat(rewrite Vlist.length_cons).
           assert(0 <= length (concat l nil)) by apply Vlist.length_pos ; omega.
        ++ rewrite rw_cons_concat in All_sep.
           intros n1 n2 ; intros.
           replace (nth (concat (cons snd1 l1'') l2) n1) with 
                   (nth (cons hd1 (concat (cons snd1 l1'') l2)) (n1+1)).
           replace (nth (concat (cons snd1 l1'') l2) n2) with 
                   (nth (cons hd1 (concat (cons snd1 l1'') l2)) (n2+1)).
           apply All_sep ; try (rewrite Vlist.length_cons ; unfold l1') ; omega.
           -- replace n2 with (n2 + 1 - 1) by omega.
              replace (n2 + 1 - 1 + 1) with (n2 + 1) by omega.
              apply Vlist.nth_cons ; omega.
           -- replace n1 with (n1 + 1 - 1) by omega.
              replace (n1 + 1 - 1 + 1) with (n1 + 1) by omega.
              apply Vlist.nth_cons ; omega.
Qed.

Goal typed_lemma_linked_ll_split.
Hint linked_ll_split,property.
Proof.
  Ltac back := repeat match goal with 
   | [ H: context [ (?hd :: ?l)%list ] |- _ ] =>
     replace (hd :: l)%list with (cons hd l) in H by reflexivity
   | [ |- context [ (?hd :: ?l)%list ] ] =>
     replace (hd :: l)%list with (cons hd l) by reflexivity
   | [ H: context [ Datatypes.nil ] |- _ ] =>
     replace Datatypes.nil with nil in H by reflexivity
   | [ |- context [ Datatypes.nil ] ] =>
     replace Datatypes.nil with nil by reflexivity
  end.

  intros Mi Ma l1 l2 bl el sl.
  unfold sl ; clear sl.
  revert l2 bl el.
  induction l1 as [ | hd l1' ] ; back ; [ congruence |].
  destruct l1' as [ | snd1 l1'' ] ; back.
  - intros l2 bl el Hnil NoDup.
    unfold nth, length ; simpl ; split.
    + replace nil with (concat nil nil) by apply rw_nil_concat_right.
      inversion NoDup as [| a b l d e Sep Valid sep NoDup' ] ; subst.
      constructor ; auto.
      * apply Q_ptr_separated_from_nil.
      * repeat(rewrite rw_nil_concat_right in H4) ; subst.
        inversion NoDup' ; subst ; auto.
        replace (Ma.[ shiftfield_F1_list_next hd])
           with (nth (cons (Ma .[ shiftfield_F1_list_next hd]) (concat l nil)) 0)
             by (unfold nth ; auto).
        apply separated_sym ; apply Sep ; try omega.
        rewrite Vlist.length_cons.
        assert(0 <= length (concat l nil)) by apply Vlist.length_pos ; omega.
      * constructor.
    + rewrite rw_cons_concat in NoDup.
      rewrite rw_nil_concat_left in NoDup.
      inversion NoDup ; subst.
      repeat(rewrite rw_nil_concat_right in H0) ; subst ; auto.
  - intros l2 bl el Hnil NoDup.
    rewrite Vlist.length_cons.
    set(l1' := cons snd1 l1'').
    destruct l2 as [ | hd2 l2' ] ; inversion NoDup ; subst ; back ;
      replace (1 + length l1' - 1) with (length l1') by omega.
    + rewrite <- rw_cons_concat in H0 ; repeat(rewrite rw_nil_concat_right in H0) ; subst.
      repeat(rewrite rw_nil_concat_right in NoDup).
      replace(Ma .[ shiftfield_F1_list_next (nth (cons hd l1') (length l1'))]) with el.
      replace l1' with (concat l1' nil) by apply rw_nil_concat_right.
      split ; constructor ; auto.
      apply Q_linked_ll_end in H8 ; subst.
      * replace (nth (cons hd l1') (length l1')) with (nth l1' (length l1' -1)).
        unfold l1' ; rewrite Vlist.length_cons ; auto.
        symmetry ; apply Vlist.nth_cons ; unfold l1' ; rewrite Vlist.length_cons.
        assert(0 <= length l1'') by apply Vlist.length_pos ; omega.
      * intros HF ; inversion HF.
    + repeat(rewrite rw_nil_concat_right in H0).
      set(l2 := cons hd2 l2').
      replace (nth (cons hd l1') (length l1')) with (nth l1' (length l1' - 1))
           by (symmetry ; apply Vlist.nth_cons ; unfold l1' ; intros HF ; inversion HF).
      set(sl := Ma .[ shiftfield_F1_list_next (nth l1' (length l1' - 1))]).
      assert(P_linked_ll Mi Ma (Ma .[ shiftfield_F1_list_next hd]) sl l1' /\ P_linked_ll Mi Ma sl el l2 ->
             P_linked_ll Mi Ma hd sl (cons hd l1') /\ P_linked_ll Mi Ma sl el l2). {
        split ; [ | apply H ].
        replace l1' with (concat l1' nil) by apply rw_nil_concat_right.
        constructor ; auto ; [ | | apply H ].
        + intros i LL Li Ui Eq.
          rewrite <- rw_cons_concat in H0.
          repeat(rewrite rw_nil_concat_right in H0).
          replace (nth l1' i) with (nth l i).
          apply H1 ; auto ; try omega.
          - subst ; rewrite Vlist.length_concat.
            assert (0 <= length (cons hd2 l2')) by apply Vlist.length_pos ; unfold l1' in * ; omega.
          - subst ; unfold l1'.
            apply Vlist.nth_concat ; unfold l1' in Ui ; auto.
        + unfold sl.
          replace (nth l1' (length l1' - 1)) with (nth l (length l1' - 1)).
          - rewrite Q_n_plus_1th_next 
                    with (t := Mi)(a_1 := Ma .[ shiftfield_F1_list_next hd])(a := el) ; auto.
            * replace (1 + (length l1' - 1)) with (length l1') by omega.
              apply separated_sym ; apply H1 ; try omega.
              ++ apply length_pos.
              ++ subst ; unfold l1' ; rewrite <- rw_cons_concat.
                 rewrite Vlist.length_concat.
                 repeat(rewrite Vlist.length_cons).
                 assert (0 <= length l2') by apply Vlist.length_pos ; omega.
            * unfold l1' ; rewrite Vlist.length_cons.
              assert(0 <= length l1'') by apply Vlist.length_pos ; omega.
            * unfold l1' in *  ; subst.
              repeat(rewrite Vlist.length_cons).
              rewrite Vlist.length_concat.
              rewrite Vlist.length_cons.
              assert (0 <= length l2') by apply Vlist.length_pos ; omega.
          - rewrite <- rw_cons_concat in H0 ; subst.
            apply Vlist.nth_concat ; omega.
      }
      apply H.
      apply IHl1'.
      * intros HF ; inversion HF.
      * unfold l1' ; unfold l2.
        repeat(rewrite rw_nil_concat_right) ; rewrite rw_cons_concat.
        inversion NoDup ; subst ; back.
        repeat(rewrite rw_nil_concat_right in H3) ; auto.
Qed.

Goal typed_lemma_linked_ll_to_logic_list.
Hint linked_ll_to_logic_list,property.
Proof.
  intros Mi Ma ll bl el NoDup ; induction NoDup.
  + rewrite A_To_ll.Q_to_ll_nil ; auto.
  + rewrite A_To_ll.Q_to_ll_cons with (t := t)(t_1 := t_1) ; subst ; auto.
Qed.

Goal typed_lemma_linked_ll_unchanged.
Hint linked_ll_unchanged,property.
Proof.
  intros Mi Mi' Ma Ma' ll bl el NoDup Unchanged.
  induction NoDup.
  + constructor.
  + constructor ; auto.
    - unfold P_unchanged in Unchanged.
      replace a_1 with (nth (cons a_1 (concat l nil)) 0) by (simpl ; auto).
      apply Unchanged ; try omega.
      assert(0 <= length (concat l nil)) by apply Vlist.length_pos.
      rewrite Vlist.length_cons ; omega.
    - unfold P_unchanged in Unchanged.
      replace (Ma .[ shiftfield_F1_list_next a_1]) with (t_1 .[ shiftfield_F1_list_next a_1]).
      * apply IHNoDup ; intros e ; intros.
        unfold a_0 ; unfold a0.
        replace e with (e + 1 - 1) by omega.
        replace (nth l (e + 1 - 1)) with (nth (cons a_1 l) (e + 1)) by (apply Vlist.nth_cons ; omega).
        replace l with (concat l nil) by apply rw_nil_concat_right.
        apply Unchanged ; try omega.
        rewrite Vlist.length_cons.
        rewrite rw_nil_concat_right.
        omega.
      * replace a_1 with (nth (cons a_1 (concat l nil)) 0) by (simpl ; auto).
        symmetry ; apply Unchanged ; try omega.
        assert(0 <= length (concat l nil)) by apply Vlist.length_pos.
        rewrite Vlist.length_cons ; omega.
Qed.

Goal typed_lemma_linked_ll_unique_list.
Hint linked_ll_unique_list,property.
Proof.
  intros Mi Ma l2 l1 bl el ND1.
  generalize dependent l2.
  induction ND1.
  + intros l2 ND2 ; inversion ND2 ; subst ; auto.
    inversion H1 ; omega.
  + intros l2 ND2.
    inversion ND2 ; subst.
    - inversion H1 ; omega.
    - assert (l0 = l) by (apply IHND1 ; auto).
      subst ; auto.
Qed.

Goal typed_lemma_ptr_separated_concat.
Hint property,ptr_separated_concat.
Proof.
  intros l1 ; induction l1 as [| h1 l1] ; intros l2 e.
  + replace Datatypes.nil with nil by reflexivity.
    rewrite rw_nil_concat_right.
    rewrite rw_nil_concat_left.
    repeat (split ; intros) ; try apply H ; apply Q_ptr_separated_from_nil.
  + replace ((h1 :: l1)%list) with (cons h1 l1) by reflexivity.
    rewrite rw_cons_concat.
    replace (cons h1 (concat l1 (concat l2 nil))) 
       with (cons h1 (concat (concat l1 (concat l2 nil)) nil))
         by (repeat(rewrite rw_nil_concat_right) ; auto).
    split ; intros H.
    - rewrite <- Q_ptr_separated_from_cons.
      replace l1 with (concat l1 nil) in H by (apply rw_nil_concat_right).
      rewrite <- Q_ptr_separated_from_cons in H.
      split ; try (rewrite <- IHl1 ; split) ; apply H.
    - rewrite <- Q_ptr_separated_from_cons in H.
      rewrite <- IHl1 in H.
      replace l1 with (concat l1 nil) by (apply rw_nil_concat_right).
      split ; try (rewrite <- Q_ptr_separated_from_cons ; split) ; apply H.
Qed.

Goal typed_lemma_ptr_separated_from_cons.
Hint property,ptr_separated_from_cons.
Proof.
  intros l ; induction l ; intros e hd ; simpl.
  + unfold cons.
    repeat(split ; intros).
    - intros i ; intros.
      assert(i = 0) by (unfold length in * ; simpl in *  ; omega) ; subst.
      simpl ; apply H.
    - apply Q_ptr_separated_from_nil.
    - unfold P_ptr_separated_from_list in H.
      assert (hd = nth (hd :: nil)%list 0) by (simpl ; auto).
      rewrite H0 ; apply H ; unfold length ; simpl ; auto ; omega.
  + unfold cons, concat.
    rewrite List.app_nil_r.
    replace ((a :: l)%list) with (cons a l) by reflexivity.
    replace l with (concat l nil) by (rewrite rw_nil_concat_right ; auto).
    replace ( (hd :: cons a (concat l nil))%list)
       with (cons hd (cons a (concat l nil)))
         by reflexivity.
    repeat(split ; intros).
    - intros i LL Li Ui.
      assert (i = 0 \/ i <> 0) by omega.
      inversion_clear H0 as [ Eq | Neq ] ; intros.
      * subst ; simpl ; apply H.
      * replace (nth (cons hd (cons a (concat l nil))) i)
           with (nth (cons a (concat l nil)) (i - 1))
             by (symmetry ; apply Vlist.nth_cons ; omega).
        apply H ; rewrite Vlist.length_cons in Ui ; omega.
    - intros i LL Li Ui ; intros.
      replace i with (i + 1 - 1) by omega.
      replace (nth (cons a (concat l nil)) (i + 1 - 1))
         with (nth (cons hd (cons a (concat l nil))) (i + 1))
           by (apply Vlist.nth_cons ; omega).
      apply H ; try rewrite Vlist.length_cons ; omega.
    - assert (hd = nth (cons hd (cons a (concat l nil)))%list 0) by (simpl ; auto).
      rewrite H0 ; apply H ; try omega.
      rewrite Vlist.length_cons.
      assert (0 <= length (cons a (concat l nil))) by apply Vlist.length_pos.
      omega.
Qed.

Goal typed_lemma_separated_linked_ll_append.
Hint property,separated_linked_ll_append.
Proof.
  intros Mi Ma ll bl el nel Valid Sep NoDup.
  generalize dependent Sep.
  induction NoDup ; intros Sep sep_a_nel.
  + simpl ; replace nil with (concat nil nil) by (simpl ; reflexivity).
    constructor ; try apply Q_ptr_separated_from_nil ; auto ; constructor.
  + replace (concat (cons a_1 (concat l nil)) (cons a nil))
       with (cons a_1 (concat (concat l (cons a nil)) nil)).
    - replace (cons a nil) with (concat (cons a nil) nil) by (simpl ; reflexivity).
      constructor ; auto.
      * rewrite <- Q_ptr_separated_concat ; split ; auto.
        intros i ; intros LL Li Ui UU ; unfold cons in *.
        assert(i = 0) by (unfold length in Ui ; simpl in Ui ; omega) ; subst.
        simpl ; apply separated_sym ; auto.
      * rewrite <- Q_ptr_separated_from_cons in Sep.
        apply Sep.
      * apply IHNoDup ; auto.
        rewrite <- Q_ptr_separated_from_cons in Sep.
        apply Sep.
    - repeat(rewrite rw_nil_concat_right).
      rewrite rw_cons_concat.
      reflexivity.
Qed.

Goal typed_lemma_separated_to_logic_list_append.
Hint property,separated_to_logic_list_append.
Proof.
  intros Mi Ma bl el nel ll Valid sep Sep NoDup.
  generalize dependent Sep.
  generalize dependent sep.
  induction NoDup ; intros sep Sep.
  + simpl ; replace nil with (concat nil nil) by (simpl ; reflexivity).
    rewrite A_To_ll.Q_to_ll_cons ; auto.
    unfold nel ; rewrite A_To_ll.Q_to_ll_nil.
    reflexivity.
  + replace (concat (cons a_1 (concat l nil)) (cons a nil))
       with (cons a_1 (concat (concat l (cons a nil)) nil)).
    - rewrite A_To_ll.Q_to_ll_cons ; auto.
      assert(Simpl: forall x l1 l2, l1 = l2 -> cons x l1 = cons x l2) by (intros ; subst ; auto).
      apply Simpl.
      * repeat(rewrite rw_nil_concat_right).
        apply IHNoDup ; auto.
        rewrite <- Q_ptr_separated_from_cons in Sep.
        apply Sep.
      * rewrite <- Q_ptr_separated_from_cons in Sep.
        apply Sep.
    - repeat(rewrite rw_nil_concat_right).
      rewrite rw_cons_concat.
      reflexivity.
Qed.

Goal typed_lemma_to_logic_list_merge.
Hint property,to_logic_list_merge.
Proof.
  Ltac simpl_nth := match goal with
  | [ _ : _ |- context [ nth (cons _ ?l) (?i + 1) = nth ?l ?i ] ] =>
    replace i with (i + 1 - 1) by omega ;
    replace (i + 1 - 1 + 1) with (i + 1) by omega ;
    apply Vlist.nth_cons ; omega
  end.

  assert(Simpl : forall hd l1 l2, l1 = l2 <-> cons hd l1 = cons hd l2). {
    intros ; split ; intros ; subst ; try (inversion H) ; auto.
  }

  intros Mi Ma bl sl el il1 ill.
  assert(H1: exists l1, l1 = il1) by (exists il1 ; auto).
  unfold ill in * ; clear ill.
  unfold il1 in * ; clear il1.
  inversion_clear H1 as [ l1 Hl1 ].
  rewrite <- Hl1.
  revert Hl1 ; revert bl sl el.

  induction l1 as [ | hd1 l1' ].
  + intros bl sl el Hl1 SepBE PtrSep AllSep NoDup1.
    inversion NoDup1 ; subst.
    replace Datatypes.nil with nil in * by reflexivity.
    rewrite rw_nil_concat_left.
    rewrite rw_nil_concat_right.
    auto.
  + replace (hd1 :: l1')%list with (cons hd1 l1') by reflexivity.
    destruct l1' as [ | snd1 l1'' ].
    - intros bl sl el Hl1 SepBE PtrSep AllSep NoDup1.
      replace Datatypes.nil with nil in * by reflexivity.
      simpl in * .
      replace (hd1 :: concat (L_to_logic_list Mi Ma sl el) nil)%list 
         with (cons hd1 (concat (L_to_logic_list Mi Ma sl el) nil)) 
           in * by reflexivity.
      inversion NoDup1 ; subst.
      rewrite A_To_ll.Q_to_ll_cons ; auto.
      * apply Simpl.
        rewrite H0.
        rewrite rw_nil_concat_right in H0 ; subst.
        inversion H8 ; subst ; auto.
      * rewrite rw_nil_concat_right in H0 ; subst.
        inversion H8 ; subst.
        rewrite rw_nil_concat_right in AllSep.
        set(tail := L_to_logic_list Mi Ma (Ma .[ shiftfield_F1_list_next hd1]) el).
        replace (L_to_logic_list Mi Ma (Ma .[ shiftfield_F1_list_next hd1]) el) 
           with tail in AllSep by auto.
        intros i ; intros.
        replace hd1 with (nth (cons hd1 tail) 0) by reflexivity.
        replace (nth tail i) with (nth (cons hd1 tail) (i + 1)) by simpl_nth.
        apply AllSep ; try rewrite Vlist.length_cons ; omega.
    - replace (snd1 :: l1'')%list with (cons snd1 l1'') in * by reflexivity.
      set(l1' := cons snd1 l1'').
      intros bl sl el Hl1 SepBE PtrSep AllSep NoDup1.
      rewrite rw_cons_concat.
      inversion NoDup1 ; subst.
      rewrite A_To_ll.Q_to_ll_cons ; auto.
      apply Simpl.
      rewrite rw_nil_concat_right in H0 ; subst.
      do 2 rewrite rw_nil_concat_right.
      rewrite A_To_ll.Q_to_ll_cons in Hl1 ; auto.
      apply Simpl in Hl1.
      apply IHl1' with (sl := sl) ; auto.
      * rewrite rw_nil_concat_right in Hl1.
        rewrite <- Hl1 ; reflexivity.
      * replace (Ma .[ Compound.shiftfield_F1_list_next hd1]) with (nth (cons hd1 l1') 1).
        ++ apply PtrSep ; try omega.
           unfold l1' ; repeat(rewrite Vlist.length_cons).
           assert(0 <= length l1'') by (apply Vlist.length_pos).
           omega.
        ++ inversion H8 ; subst ; reflexivity.
      * replace (cons snd1 l1'') with l1' by reflexivity.
        clear AllSep NoDup1 H1 H2 H7 H8.
        intros x ; intros.
        replace (nth l1' x) with (nth (cons hd1 l1') (x+1)) by simpl_nth.
        apply PtrSep ; try omega.
        rewrite Vlist.length_cons ; omega.
      * rewrite rw_cons_concat in AllSep.
        clear IHl1' SepBE Hl1 PtrSep NoDup1 H1 H2 H7 H8.
        set(l2 := concat (L_to_logic_list Mi Ma sl el) nil).
        replace (concat (L_to_logic_list Mi Ma sl el) nil) with l2 in AllSep by reflexivity.
        intros n1 n2 ; intros.
        replace (nth (concat (cons snd1 l1'') l2) n1) 
           with (nth (cons hd1 (concat (cons snd1 l1'') l2)) (n1+1))
             by simpl_nth.
        replace (nth (concat (cons snd1 l1'') l2) n2) 
           with (nth (cons hd1 (concat (cons snd1 l1'') l2)) (n2+1))
             by simpl_nth.
        apply AllSep ; try (rewrite Vlist.length_cons ; unfold l1') ; omega.
      * apply Q_linked_ll_to_logic_list in H8 ; rewrite H8 ; auto.
      * rewrite rw_nil_concat_right in H0 ; subst.
        rewrite rw_cons_concat in AllSep.
        rewrite <- IHl1' with (bl := Ma .[ shiftfield_F1_list_next hd1]) in AllSep ; auto.
        ++ set (tail := L_to_logic_list Mi Ma (Ma .[ shiftfield_F1_list_next hd1]) el).
           replace (L_to_logic_list Mi Ma (Ma .[ shiftfield_F1_list_next hd1]) el) 
              with tail in AllSep by auto.
           intros i ; intros.
           replace hd1 with (nth (cons hd1 tail) 0) by reflexivity.
           replace (nth tail i) with (nth (cons hd1 tail) (i + 1)) by simpl_nth.
           apply AllSep ; try rewrite Vlist.length_cons ; omega.
        ++ apply Q_linked_ll_to_logic_list in H8 ; unfold l1' in H8 ; auto.
        ++ unfold l1' in PtrSep.
           unfold l1' in H8 ; inversion H8 ; subst.
           replace (Ma .[ shiftfield_F1_list_next hd1]) 
              with (nth (cons hd1 (cons (Ma .[ shiftfield_F1_list_next hd1]) (concat l nil))) 1) 
                by (unfold nth ; unfold cons ; simpl ; auto).
           apply PtrSep ; try omega.
           repeat rewrite length_cons ; assert (0 <= length (concat l nil)) by apply length_pos ; omega.
        ++ replace (cons snd1 l1'') with l1' by auto.
           intros i ; intros.
           replace (nth l1' i) with (nth (cons hd1 l1') (i + 1)) by simpl_nth.
           apply PtrSep ; repeat rewrite length_cons ; assert (0 <= length l1') by apply length_pos ; omega.
        ++ replace (cons snd1 l1'') with l1' by auto.
           set(tail := concat l1' (concat (L_to_logic_list Mi Ma sl el) nil)).
           replace (concat l1' (concat (L_to_logic_list Mi Ma sl el) nil)) with tail in AllSep by auto.
           intros n1 n2 ; intros.
           replace (nth tail n1) with (nth (cons hd1 tail) (n1+1)) by simpl_nth.
           replace (nth tail n2) with (nth (cons hd1 tail) (n2+1)) by simpl_nth.
           assert(0 <= length tail) by apply length_pos.
           apply AllSep ; try (rewrite Vlist.length_cons) ; omega.
Qed.

Goal typed_lemma_to_logic_list_split.
Hint property,to_logic_list_split.
Proof.
  intros Mi Ma bl el sep ll.
  assert(exists ill, ill = ll) by (exists (L_to_logic_list Mi Ma bl el) ; auto).
  unfold ll in * ; clear ll ; inversion_clear H as [ ll Heq ].
  rewrite <- Heq.
  intros Hnil In NoDup.
  revert Hnil In Heq. revert sep.
  induction NoDup as [ | Mi Ma ll' hd el Hsep_ll' ValidHd Hsep_be ] ; [ congruence |] ; intros.
  assert(Hsep: sep = hd \/ P_in_list sep ll' ). {
    inversion_clear In as [ x In' ].
    assert (Hx: x = 0 \/ 0 < x < length (cons hd (concat ll' nil))) by omega.
    inversion_clear Hx as [ | In_ll' ] ; subst ; [ left | right ].
    + unfold nth in In' ; simpl in In' ; symmetry ; apply In'.
    + repeat(rewrite rw_nil_concat_right in In').
      repeat(rewrite rw_nil_concat_right in In_ll').
      rewrite Vlist.length_cons in In_ll'.
      replace (nth (cons hd ll') x) with (nth ll' (x-1)) in In'
           by (symmetry ; apply Vlist.nth_cons ; omega).
      exists (x-1) ; split ; [ apply In' | omega ].
  }
  inversion NoDup ; inversion Hsep as [ | In_ll'] ; subst.
  + rewrite A_To_ll.Q_to_ll_nil.
    repeat(rewrite rw_nil_concat_left).
    rewrite A_To_ll.Q_to_ll_cons with (t := Mi) ; auto ; rewrite A_To_ll.Q_to_ll_nil ; auto.
  + inversion_clear In_ll' as [ x HF ].
    unfold length in HF ; simpl in HF ; omega.
  + rewrite A_To_ll.Q_to_ll_nil.
    set(nhd := Ma .[ Compound.shiftfield_F1_list_next hd]).
    replace (Ma .[ Compound.shiftfield_F1_list_next hd]) with nhd in * by reflexivity.
    rewrite rw_nil_concat_left.
    repeat(rewrite rw_nil_concat_right).
    repeat(rewrite rw_nil_concat_right in Heq).
    assumption.
  + set(nhd := Ma .[ Compound.shiftfield_F1_list_next hd]).
    rewrite A_To_ll.Q_to_ll_cons with (t := Mi) ; auto ;
      replace (Ma .[ Compound.shiftfield_F1_list_next hd]) with nhd in * by reflexivity.
    - repeat(rewrite rw_cons_concat).
      rewrite rw_nil_concat_right with (w := (cons nhd (concat l nil))).
      assert(Simpl : forall hd l1 l2, l1 = l2 <-> cons hd l1 = cons hd l2). {
        intros ; split ; intros HH.
        + subst ; auto.
        + inversion HH ; auto.
      }
      apply Simpl.
      replace (concat (L_to_logic_list Mi Ma nhd sep) nil)
         with (L_to_logic_list Mi Ma nhd sep)
           by (rewrite rw_nil_concat_right ; auto).
      apply IHNoDup ; auto.
      * intros HF ; inversion HF.
      * rewrite A_To_ll.Q_to_ll_cons with (t := Mi) in Heq ; auto.
        apply Simpl in Heq.
        repeat(rewrite rw_nil_concat_right in Heq).
        rewrite rw_nil_concat_right.
        unfold nhd.
        rewrite <- Heq ; reflexivity.
        assert (Val: L_to_logic_list Mi Ma (Ma .[ shiftfield_F1_list_next hd]) el = cons nhd (concat l nil))
            by (apply Q_linked_ll_to_logic_list ; auto).
        rewrite Val ; auto.
    - inversion_clear In_ll' as [ pos Hpos ].
      inversion_clear Hpos as [ PosEq PosB ].
      rewrite <- PosEq.
      apply separated_sym.
      apply Hsep_ll' ; auto ; omega.
    - apply Q_ptr_separated_concat with (l := L_to_logic_list Mi Ma sep el).
      rewrite <- IHNoDup ; auto.
      * intros HF ; inversion HF.
      * symmetry ; apply Q_linked_ll_to_logic_list ; auto.
Qed.

Goal typed_lemma_unchanged_sublists.
Hint property,unchanged_sublists.
Proof.
  intros Mi1 Mi2 Ma1 Ma2 l1 l2.
  rewrite rw_nil_concat_right.
  split ; intros H.
  + inversion H as [ U2 U1 ].
    intros i a next BiInf BiSup.
    unfold a in * ; clear a.
    unfold next in * ; clear next.
    assert(Bi: i < length l1 \/ length l1 <= i) by omega.
    inversion_clear Bi as [ Inf | Sup ].
    - replace (nth (concat l1 l2) i) with (nth l1 i) 
           by (symmetry ; apply Vlist.nth_concat ; omega).
      apply U1 ; omega.
    - replace (nth (concat l1 l2) i) with (nth l2 (i - length l1))
           by (symmetry ; apply Vlist.nth_concat ; omega).
      rewrite Vlist.length_concat in BiSup.
      apply U2 ; omega.
  + split ; intros i a next BiInf BiSup ;
      unfold a in * ; clear a ;
      unfold next in * ; clear next.
    - replace (nth l2 i) with (nth (concat l1 l2) (length l1 + i)).
      apply H.
      * assert (0 <= length l1) by apply length_pos.
        omega.
      * rewrite Vlist.length_concat.
        omega.
      * replace i with (i + length l1 - length l1) by omega.
        replace (length l1 + (i + length l1 - length l1)) with (i + length l1) by omega.
        apply Vlist.nth_concat ; omega.
    - replace (nth l1 i) with (nth (concat l1 l2) i) by (apply Vlist.nth_concat ; omega).
      apply H.
      * omega.
      * rewrite Vlist.length_concat.
        assert (0 <= length l2) by apply length_pos.
        omega.
Qed.

Goal typed_list_insert_stmt_post_EASY.
Hint EASY,default,list_insert,property.
Proof.
(* auto with zarith. *)
Qed.

Goal typed_list_insert_stmt_post_EASY_Left.
Hint EASY_Left,default,list_insert,property.
Proof.
  intros.
  symmetry in H7.
  unfold a_18.
  subst.
  repeat rewrite rw_nil_concat_right.
  repeat rewrite rw_nil_concat_right in H7.
  rewrite H1 in H7.
  rewrite H3 in H7.
  assert(HH: forall l1 l2 l3, concat l2 l1 = concat l3 l1 -> l2 = l3). {
    apply List.app_inv_tail.
  }
  replace (concat a_13 (concat (L_to_logic_list t t_2 a_9 a_5) (L_to_logic_list t t_2 a_5 null)))
     with (concat (concat a_13 (L_to_logic_list t t_2 a_9 a_5)) (L_to_logic_list t t_2 a_5 null))
       in H7.
  unfold a_11 in H7.
  apply HH in H7 ; auto.
  symmetry ; apply List.app_assoc.
Qed.

Goal typed_list_insert_stmt_post_EASY_Right.
Hint EASY_Right,default,list_insert,property.
Proof.
  intros.
  symmetry in H6.
  unfold a_14.
  subst.
  repeat rewrite rw_nil_concat_right.
  repeat rewrite rw_nil_concat_right in H6.
  rewrite H4 in H6.
  rewrite H1 in H6.
  assert(HH: forall l1 l2 l3, concat l1 l2 = concat l1 l3 -> l2 = l3). {
    apply List.app_inv_head.
  }
  apply HH with (l1 := a_13) ; auto.
Qed.


